% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/na.replace.R, R/na.zero.R
\name{na.replace}
\alias{na.replace}
\alias{na.explicit}
\alias{na.zero}
\title{Replace NAs with explicit values}
\usage{
na.replace(x, .na, ...)

na.explicit(x, .na)

na.zero(x)
}
\arguments{
\item{x}{vector in which \code{NA} values are to be replaced.}

\item{.na}{scalar, length(x)-vector or function used to replace \code{NA}.
See #Details.}

\item{x}{vector of values to have the NA replaced with \code{value}}
}
\value{
A vector with the class and length of \code{x}.
\code{NA}s in \code{x} will be replaced by \code{.na}. \code{.na} is coerced as necessary.

\code{x} with \code{NA}s replaced by 0.
}
\description{
Replaces \code{NA} values with explicit values.

Replaces \code{NA}s by 0.
}
\details{
\code{na.replace} replaces missing values in \code{x} by \code{.na}.

Replacement is both class/type and length safe meaning the result
is guaranteed to be the same class/type and length of \code{x} regardless of the
value of \code{.na}.

\strong{Param: \code{x}}

If \code{x} is \strong{categorical} (e.g. character or factor), \code{.na} is optional.
The default is "(NA)" and can be set with
\code{options( NA_explicit_ = new_value )}. It can also be
referenced directly with \link{NA_explicit_}.

If \code{x} is a \strong{factor}, unique values of \code{.na} not in already present in
\code{levels(x)} will be added. They are appended silently unless
\code{getOption('verbose')==TRUE} in which a message reports the added levels.

\strong{Param: \code{.na}}

\code{.na} can be either a scalar, vector or function.

If a \strong{scalar}, each missing value of \code{x} is replaced by \code{na}.

If a \strong{vector}, \code{.na} must have length(x)\code{. Missing values of}x\code{are replaced by corresponding elements of}.na\code{. Recycling values of}.na\code{is not performed. An error will be thrown in the event that}length(.na)\code{is not}1\code{or}length(x)\code{.}

If a \strong{function}, \code{x} is transformed by .na` with:\preformatted{     .na( na.omit(x) )
}

then preceding with normal operations.

\code{na.explicit} is an alias for na.replace that is likely to be deprecated.

\code{na_zero} replaces missing values with \code{0}. It is coerced to character or
factor as needed.
}
\examples{

  # Integers and numerics
  na.replace( c(1,NA,3,NA), 2 )    # 1 2 3 2   
  na.replace( c(1,NA,3,NA), 1:4 )  # 1 2 3 4

  na.replace( c(1,NA,3,NA), letters[1:4] )  # "1" "b" "3" "d"

  # Characters 
  lets <- letters[1:5]
  lets[ c(2,4) ] <- NA
  lets \%>\% na.replace

  # Factors 
  fct <- as.factor( c( NA, letters[2:4], NA) )
  fct
  na.replace(fct, "z")  # z b c d z  -- level z added
  na.replace(fct, letters[1:5] )
  na.replace(fct)
     
     
 
  library(mtcars) 
  mtcars <- head(mtcars)
  mtcars[3,] <- NA
  
  
  mtcars \%>\% na_zero(mpg, cyl)
  mtcars \%>\% na_zero(1,2:4)
  mtcars \%>\% na_zero("mpg", "cyl")
  
  na_zero_at( mtcars, "cyl" )
  na_zero_at( mtcars, c("mpg","cyl"))
  na_zero_at( mtcars, 2 )
  na_zero_at( mtcars, 1:3)

  na_zero_all( mtcars )  
          
  na_zero_if( mtcars, mean(.) > 10 )   
           
}
\seealso{
\itemize{
\item \code{\link[=na_explicit]{na_explicit()}} for a similar function that additionally handles recursive
\item and table-like objects
\item \code{\link[base:ifelse]{base::ifelse()}}, \code{\link[base:replace]{base::replace()}}
\item \code{forcats::fct_explicit_na} - which only handles factors
}

\code{\link[=na.replace]{na.replace()}}
\code{\link[=na.constant]{na.constant()}}
}
